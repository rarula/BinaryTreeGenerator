import JSZip from 'jszip';

import { FixedSettings } from '../types/Settings';
import { split } from '../utils/array';
import { range } from '../utils/number';
import { join } from '../utils/resourcePath';

const packMcmeta = {
    pack: {
        pack_format: 12,
        description: 'Generated by Binary Branch Generator',
    },
};

type BinaryTree = {
    values: number[];
    low?: BinaryTree;
    high?: BinaryTree;
};

function generateBinaryTree(values: number[]): BinaryTree {
    if (values.length === 1) {
        return { values: values };
    }

    const [low, high] = split(values);

    const lowTree = generateBinaryTree(low);
    const highTree = generateBinaryTree(high);

    return {
        values: values,
        low: lowTree,
        high: highTree,
    };
}

function getCommand(commands: string | string[], replaceValue: string): string {
    if (typeof commands === 'string') {
        return commands.replaceAll('$i', replaceValue);
    } else {
        return commands.map((command) => {
            return command.replaceAll('$i', replaceValue);
        }).join('\n');
    }
}

export function createDatapack(zip: JSZip, settings: FixedSettings): void {
    const zipFunc = zip.folder(`data/${settings.namespace}/functions/${settings.folder}`);
    if (!zipFunc) return;

    const binaryTree = generateBinaryTree(range(settings.min, settings.max));
    const isSingleCommand = settings.commands.length === 1;

    let treeList: BinaryTree[] = [];
    let nextTreeList: BinaryTree[] = [];

    treeList.push(binaryTree);

    for (let i = 0; 0 < treeList.length; i++) {
        const folderName = `b-${i}`;
        let nextFileNum = 0;

        for (let j = 0; j < treeList.length; j++) {
            const fileName = `${j}.mcfunction`;
            const currentTree = treeList[j];

            if (currentTree.low && currentTree.high) {
                const trees: BinaryTree[] = [
                    currentTree.low,
                    currentTree.high,
                ];
                let text = '';

                for (const tree of trees) {
                    text += `execute if score ${settings.scoreHolder} ${settings.objective} matches `;

                    if (tree.values.length === 1) {
                        if (isSingleCommand) {
                            const value = tree.values[0];
                            const output = getCommand(settings.commands[0], value.toString());
                            text += `${value} run ${output}`;
                        } else {
                            const value = tree.values[0];
                            const path = join(settings.namespace, settings.folder, 'b-end', `${value}`);
                            text += `${value} run function ${path}`;

                            const text2 = getCommand(settings.commands, value.toString());
                            zipFunc.file(`b-end/${value}.mcfunction`, text2);
                        }
                    } else {
                        const min = tree.values.at(0);
                        const max = tree.values.at(-1);
                        const path = join(settings.namespace, settings.folder, `b-${i + 1}`, `${nextFileNum}`);
                        text += `${min}..${max} run function ${path}`;

                        nextTreeList.push(tree);
                        nextFileNum++;
                    }
                    text += '\n';
                }
                zipFunc.file(`${folderName}/${fileName}`, text);
            }
        }
        treeList = nextTreeList;
        nextTreeList = [];
    }

    zip.file('pack.mcmeta', JSON.stringify(packMcmeta, null, 4));
}
