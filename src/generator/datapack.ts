import JSZip from 'jszip';

import { FixedSettings } from '../types/Settings';
import { split } from '../utils/array';
import { range } from '../utils/number';
import { join } from '../utils/resourcePath';

const packMcmeta = {
    pack: {
        pack_format: 12,
        description: 'Generated by Binary Branch Generator',
    },
};

type File = {
    tree: BinaryTree;
    caller?: {
        folderNum: number;
        fileNum: number;
    };
};

type BinaryTree = {
    values: number[];
    low?: BinaryTree;
    high?: BinaryTree;
};

function generateBinaryTree(values: number[]): BinaryTree {
    if (values.length === 1) {
        return { values: values };
    }

    const [low, high] = split(values);

    const lowTree = generateBinaryTree(low);
    const highTree = generateBinaryTree(high);

    return {
        values: values,
        low: lowTree,
        high: highTree,
    };
}

function getCommand(commands: string | string[], replaceValue: string): string {
    if (typeof commands === 'string') {
        return commands.replaceAll('$i', replaceValue);
    } else {
        return commands.map((command) => {
            return command.replaceAll('$i', replaceValue);
        }).join('\n');
    }
}

export function createDatapack(zip: JSZip, settings: FixedSettings): void {
    const functions = zip.folder(`data/${settings.namespace}/functions/${settings.path}`);
    if (!functions) return;

    const isSingleCommand = settings.commands.length === 1;

    const binaryTree = generateBinaryTree(range(settings.min, settings.max));
    let nextFolder: File[] = [];
    let folder: File[] = [];

    folder.push({
        tree: binaryTree,
    });

    for (let folderNum = 0; 0 < folder.length; folderNum++) {
        let nextFileNum = 0;

        for (let fileNum = 0; fileNum < folder.length; fileNum++) {
            const file = folder[fileNum];

            if (file.tree.low && file.tree.high) {
                const trees: BinaryTree[] = [
                    file.tree.low,
                    file.tree.high,
                ];

                let text = '';
                if (settings.useImpDoc) {
                    text += `#> ${join(settings.namespace, settings.path, `b-${folderNum}`, fileNum.toString())}`;
                    text += '\n';

                    if (file.caller) {
                        text += `# @within function ${join(settings.namespace, settings.path, `b-${file.caller.folderNum}`, file.caller.fileNum.toString())}`;
                    } else {
                        text += `# @within * ${join(settings.namespace, settings.path, '**')}`;
                    }

                    text += '\n\n';
                }

                for (const tree of trees) {
                    text += `execute if score ${settings.scoreHolder} ${settings.objective} matches `;

                    if (tree.values.length === 1) {
                        if (isSingleCommand) {
                            const value = tree.values[0];
                            const output = getCommand(settings.commands[0], value.toString());
                            text += `${value} run ${output}`;
                        } else {
                            const value = tree.values[0];
                            const path = join(settings.namespace, settings.path, 'b-end', `${value}`);
                            text += `${value} run function ${path}`;

                            let text2 = '';
                            if (settings.useImpDoc) {
                                text2 += `#> ${join(settings.namespace, settings.path, 'b-end', value.toString())}`;
                                text2 += '\n';

                                text2 += `# @within function ${join(settings.namespace, settings.path, `b-${folderNum}`, fileNum.toString())}`;
                                text2 += '\n\n';
                            }

                            // 複数のコマンドを出力するファイルを作成
                            text2 += getCommand(settings.commands, value.toString());
                            functions.file(`b-end/${value}.mcfunction`, text2);
                        }
                    } else {
                        const min = tree.values.at(0);
                        const max = tree.values.at(-1);
                        const path = join(settings.namespace, settings.path, `b-${folderNum + 1}`, `${nextFileNum}`);
                        text += `${min}..${max} run function ${path}`;

                        const nextFile: File = {
                            tree: tree,
                            caller: {
                                folderNum: folderNum,
                                fileNum: fileNum,
                            },
                        };

                        nextFolder.push(nextFile);
                        nextFileNum++;
                    }

                    text += '\n';
                }

                functions.file(`b-${folderNum}/${fileNum}.mcfunction`, text);
            }
        }

        folder = nextFolder;
        nextFolder = [];
    }

    zip.file('pack.mcmeta', JSON.stringify(packMcmeta, null, 4));
}
